(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require map.Map.
Require map.Occ.
Require map.MapPermut.
Require map.MapInjection.
Require list.List.

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | mk_ref : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments mk_ref {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | mk_ref x => x
  end.

Axiom array : forall (a:Type), Type.
Parameter array_WhyType :
  forall (a:Type) {a_WT:WhyType a}, WhyType (array a).
Existing Instance array_WhyType.

Parameter elts:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a.

Parameter length:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z.

Axiom array'invariant :
  forall {a:Type} {a_WT:WhyType a},
  forall (self:array a), (0%Z <= (length self))%Z.

(* Why3 assumption *)
Definition mixfix_lbrb {a:Type} {a_WT:WhyType a} (a1:array a)
    (i:Numbers.BinNums.Z) : a :=
  elts a1 i.

Parameter mixfix_lblsmnrb:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a ->
  array a.

Axiom mixfix_lblsmnrb_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  ((length (mixfix_lblsmnrb a1 i v)) = (length a1)) /\
  ((elts (mixfix_lblsmnrb a1 i v)) = (map.Map.set (elts a1) i v)).

Parameter make:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z -> a -> array a.

Axiom make_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Numbers.BinNums.Z) (v:a), (0%Z <= n)%Z ->
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < n)%Z ->
   ((mixfix_lbrb (make n v) i) = v)) /\
  ((length (make n v)) = n).

(* Why3 assumption *)
Definition injective (a:array Numbers.BinNums.Z) : Prop :=
  map.MapInjection.injective (elts a) (length a).

(* Why3 assumption *)
Definition surjective (a:array Numbers.BinNums.Z) : Prop :=
  map.MapInjection.surjective (elts a) (length a).

(* Why3 assumption *)
Definition range (a:array Numbers.BinNums.Z) : Prop :=
  map.MapInjection.range (elts a) (length a).

(* Why3 assumption *)
Definition range_sub (a:array Numbers.BinNums.Z) (l:Numbers.BinNums.Z)
    (u:Numbers.BinNums.Z) (b:Numbers.BinNums.Z) : Prop :=
  forall (i:Numbers.BinNums.Z), (l <= i)%Z /\ (i < u)%Z ->
  (0%Z <= (elts a i))%Z /\ ((elts a i) < b)%Z.

(* Why3 assumption *)
Definition inj_sub (a:array Numbers.BinNums.Z) (l:Numbers.BinNums.Z)
    (u:Numbers.BinNums.Z) : Prop :=
  forall (i:Numbers.BinNums.Z), (l <= i)%Z /\ (i < u)%Z ->
  forall (j:Numbers.BinNums.Z), (l <= j)%Z /\ (j < u)%Z -> ~ (i = j) ->
  ~ ((elts a i) = (elts a j)).

Axiom injective_surjective :
  forall (a:array Numbers.BinNums.Z), injective a -> range a -> surjective a.

Axiom injection_occ :
  forall (a:array Numbers.BinNums.Z),
  injective a <->
  (forall (v:Numbers.BinNums.Z),
   ((map.Occ.occ v (elts a) 0%Z (length a)) <= 1%Z)%Z).

Axiom endoinjection_occ :
  forall (a:array Numbers.BinNums.Z),
  map.MapInjection.range (elts a) (length a) /\ injective a ->
  forall (v:Numbers.BinNums.Z), (0%Z <= v)%Z /\ (v < (length a))%Z ->
  ((map.Occ.occ v (elts a) 0%Z (length a)) = 1%Z).

(* Why3 assumption *)
Definition map_eq_sub {a:Type} {a_WT:WhyType a} (a1:Numbers.BinNums.Z -> a)
    (a2:Numbers.BinNums.Z -> a) (l:Numbers.BinNums.Z) (u:Numbers.BinNums.Z) :
    Prop :=
  forall (i:Numbers.BinNums.Z), (l <= i)%Z /\ (i < u)%Z -> ((a1 i) = (a2 i)).

(* Why3 assumption *)
Definition array_eq_sub {a:Type} {a_WT:WhyType a} (a1:array a) (a2:array a)
    (l:Numbers.BinNums.Z) (u:Numbers.BinNums.Z) : Prop :=
  ((length a1) = (length a2)) /\
  ((0%Z <= l)%Z /\ (l <= (length a1))%Z) /\
  ((0%Z <= u)%Z /\ (u <= (length a1))%Z) /\
  map_eq_sub (elts a1) (elts a2) l u.

(* Why3 assumption *)
Definition array_eq {a:Type} {a_WT:WhyType a} (a1:array a) (a2:array a) :
    Prop :=
  ((length a1) = (length a2)) /\
  map_eq_sub (elts a1) (elts a2) 0%Z (length a1).

(* Why3 assumption *)
Definition lt_lex_sub_at (a1:array Numbers.BinNums.Z)
    (a2:array Numbers.BinNums.Z) (l:Numbers.BinNums.Z) (u:Numbers.BinNums.Z)
    (i:Numbers.BinNums.Z) : Prop :=
  ((l <= i)%Z /\ (i < u)%Z) /\
  array_eq_sub a1 a2 l i /\ ((mixfix_lbrb a1 i) < (mixfix_lbrb a2 i))%Z.

(* Why3 assumption *)
Definition lt_lex_at (a1:array Numbers.BinNums.Z)
    (a2:array Numbers.BinNums.Z) (i:Numbers.BinNums.Z) : Prop :=
  ((length a1) = (length a2)) /\ lt_lex_sub_at a1 a2 0%Z (length a1) i.

(* Why3 assumption *)
Definition lt_lex_sub (a1:array Numbers.BinNums.Z)
    (a2:array Numbers.BinNums.Z) (l:Numbers.BinNums.Z)
    (u:Numbers.BinNums.Z) : Prop :=
  exists i:Numbers.BinNums.Z, lt_lex_sub_at a1 a2 l u i.

(* Why3 assumption *)
Definition lt_lex (a1:array Numbers.BinNums.Z) (a2:array Numbers.BinNums.Z) :
    Prop :=
  ((length a1) = (length a2)) /\ lt_lex_sub a1 a2 0%Z (length a1).

(* Why3 assumption *)
Definition le_lex_sub (a1:array Numbers.BinNums.Z)
    (a2:array Numbers.BinNums.Z) (l:Numbers.BinNums.Z)
    (u:Numbers.BinNums.Z) : Prop :=
  lt_lex_sub a1 a2 l u \/ array_eq_sub a1 a2 l u.

(* Why3 assumption *)
Definition le_lex (a1:array Numbers.BinNums.Z) (a2:array Numbers.BinNums.Z) :
    Prop :=
  ((length a1) = (length a2)) /\ le_lex_sub a1 a2 0%Z (length a1).

Axiom prefix_le_lex_sub :
  forall (a:array Numbers.BinNums.Z) (b:array Numbers.BinNums.Z)
    (l:Numbers.BinNums.Z) (u:Numbers.BinNums.Z),
  array_eq_sub a b 0%Z l /\ le_lex_sub a b l u -> le_lex_sub a b 0%Z u.

Axiom not_array_eq_sub :
  forall (a:array Numbers.BinNums.Z) (b:array Numbers.BinNums.Z)
    (l:Numbers.BinNums.Z) (u:Numbers.BinNums.Z),
  (0%Z <= l)%Z /\
  (l < u)%Z /\ (u <= (length a))%Z /\ ((length a) = (length b)) ->
  ~ array_eq_sub a b l u ->
  exists i:Numbers.BinNums.Z,
  ((l <= i)%Z /\ (i < u)%Z) /\
  array_eq_sub a b l i /\ ~ ((mixfix_lbrb a i) = (mixfix_lbrb b i)).

Axiom total_order :
  forall (a:array Numbers.BinNums.Z) (b:array Numbers.BinNums.Z)
    (l:Numbers.BinNums.Z) (u:Numbers.BinNums.Z),
  ((0%Z <= l)%Z /\
   (l < u)%Z /\ (u <= (length a))%Z /\ ((length a) = (length b))) /\
  ~ lt_lex_sub b a l u -> le_lex_sub a b l u.

(* Why3 assumption *)
Definition exchange {a:Type} {a_WT:WhyType a} (a1:Numbers.BinNums.Z -> a)
    (a2:Numbers.BinNums.Z -> a) (l:Numbers.BinNums.Z) (u:Numbers.BinNums.Z)
    (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z) : Prop :=
  ((l <= i)%Z /\ (i < u)%Z) /\
  ((l <= j)%Z /\ (j < u)%Z) /\
  ((a1 i) = (a2 j)) /\
  ((a1 j) = (a2 i)) /\
  (forall (k:Numbers.BinNums.Z), (l <= k)%Z /\ (k < u)%Z -> ~ (k = i) ->
   ~ (k = j) -> ((a1 k) = (a2 k))).

Axiom exchange_set :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:Numbers.BinNums.Z -> a) (l:Numbers.BinNums.Z)
    (u:Numbers.BinNums.Z) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (l <= i)%Z /\ (i < u)%Z -> (l <= j)%Z /\ (j < u)%Z ->
  exchange a1 (map.Map.set (map.Map.set a1 i (a1 j)) j (a1 i)) l u i j.

(* Why3 assumption *)
Definition exchange1 {a:Type} {a_WT:WhyType a} (a1:array a) (a2:array a)
    (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z) : Prop :=
  ((length a1) = (length a2)) /\
  exchange (elts a1) (elts a2) 0%Z (length a1) i j.

(* Why3 assumption *)
Definition permut {a:Type} {a_WT:WhyType a} (a1:array a) (a2:array a)
    (l:Numbers.BinNums.Z) (u:Numbers.BinNums.Z) : Prop :=
  ((length a1) = (length a2)) /\
  ((0%Z <= l)%Z /\ (l <= (length a1))%Z) /\
  ((0%Z <= u)%Z /\ (u <= (length a1))%Z) /\
  map.MapPermut.permut (elts a1) (elts a2) l u.

(* Why3 assumption *)
Definition permut_sub {a:Type} {a_WT:WhyType a} (a1:array a) (a2:array a)
    (l:Numbers.BinNums.Z) (u:Numbers.BinNums.Z) : Prop :=
  map_eq_sub (elts a1) (elts a2) 0%Z l /\
  permut a1 a2 l u /\ map_eq_sub (elts a1) (elts a2) u (length a1).

(* Why3 assumption *)
Definition permut_all {a:Type} {a_WT:WhyType a} (a1:array a) (a2:array a) :
    Prop :=
  ((length a1) = (length a2)) /\
  map.MapPermut.permut (elts a1) (elts a2) 0%Z (length a1).

Axiom exchange_permut_sub :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (a2:array a) (i:Numbers.BinNums.Z)
    (j:Numbers.BinNums.Z) (l:Numbers.BinNums.Z) (u:Numbers.BinNums.Z),
  exchange1 a1 a2 i j -> (l <= i)%Z /\ (i < u)%Z ->
  (l <= j)%Z /\ (j < u)%Z -> (0%Z <= l)%Z -> (u <= (length a1))%Z ->
  permut_sub a1 a2 l u.

Axiom permut_sub_weakening :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (a2:array a) (l1:Numbers.BinNums.Z)
    (u1:Numbers.BinNums.Z) (l2:Numbers.BinNums.Z) (u2:Numbers.BinNums.Z),
  permut_sub a1 a2 l1 u1 -> (0%Z <= l2)%Z /\ (l2 <= l1)%Z ->
  (u1 <= u2)%Z /\ (u2 <= (length a1))%Z -> permut_sub a1 a2 l2 u2.

Axiom exchange_permut_all :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (a2:array a) (i:Numbers.BinNums.Z)
    (j:Numbers.BinNums.Z),
  exchange1 a1 a2 i j -> permut_all a1 a2.

(* Why3 assumption *)
Definition is_permut (a:array Numbers.BinNums.Z) : Prop :=
  range a /\ injective a.

Axiom endoinj_permut :
  forall (a:array Numbers.BinNums.Z) (b:array Numbers.BinNums.Z),
  ((0%Z <= (length a))%Z /\ ((length a) = (length b))) /\
  is_permut a /\ is_permut b -> permut a b 0%Z (length a).

(* Why3 assumption *)
Definition is_id_sub (a:array Numbers.BinNums.Z) (l:Numbers.BinNums.Z)
    (u:Numbers.BinNums.Z) : Prop :=
  forall (i:Numbers.BinNums.Z), (l <= i)%Z /\ (i < u)%Z ->
  ((mixfix_lbrb a i) = i).

(* Why3 assumption *)
Definition im_sup1 (a:array Numbers.BinNums.Z) (r:Numbers.BinNums.Z)
    (k:Numbers.BinNums.Z) : Prop :=
  forall (i:Numbers.BinNums.Z), (r < i)%Z /\ (i < k)%Z ->
  ((mixfix_lbrb a k) < (mixfix_lbrb a i))%Z.

(* Why3 assumption *)
Definition im_sup2 (a:array Numbers.BinNums.Z) (r:Numbers.BinNums.Z)
    (k:Numbers.BinNums.Z) : Prop :=
  forall (i:Numbers.BinNums.Z), (k < i)%Z /\ (i < (length a))%Z ->
  ((mixfix_lbrb a i) < (mixfix_lbrb a r))%Z.

(* Why3 assumption *)
Definition is_inc_sub (a:array Numbers.BinNums.Z) (l:Numbers.BinNums.Z)
    (u:Numbers.BinNums.Z) : Prop :=
  forall (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (l <= i)%Z /\ (i < j)%Z /\ (j < u)%Z ->
  ((mixfix_lbrb a i) < (mixfix_lbrb a j))%Z.

(* Why3 assumption *)
Definition is_inc (a:array Numbers.BinNums.Z) : Prop :=
  is_inc_sub a 0%Z (length a).

(* Why3 assumption *)
Definition is_dec_sub (a:array Numbers.BinNums.Z) (l:Numbers.BinNums.Z)
    (u:Numbers.BinNums.Z) : Prop :=
  forall (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (l <= i)%Z /\ (i < j)%Z /\ (j < u)%Z ->
  ((mixfix_lbrb a j) < (mixfix_lbrb a i))%Z.

Axiom min_lex_sub :
  forall (a:array Numbers.BinNums.Z) (l:Numbers.BinNums.Z)
    (u:Numbers.BinNums.Z),
  ((0%Z <= l)%Z /\ (l < u)%Z /\ (u <= (length a))%Z) /\
  injective a /\ is_inc_sub a l u -> forall (b:array Numbers.BinNums.Z),
  permut a b l u /\ injective b -> le_lex_sub a b l u.

Axiom max_lex_sub :
  forall (a:array Numbers.BinNums.Z) (l:Numbers.BinNums.Z)
    (u:Numbers.BinNums.Z),
  ((0%Z <= l)%Z /\ (l < u)%Z /\ (u <= (length a))%Z) /\
  injective a /\ is_dec_sub a l u -> forall (b:array Numbers.BinNums.Z),
  permut a b l u /\ injective b -> le_lex_sub b a l u.

(* Why3 assumption *)
Definition min_lex (a:array Numbers.BinNums.Z) : Prop :=
  forall (b:array Numbers.BinNums.Z),
  ((length a) = (length b)) /\ is_permut b -> le_lex_sub a b 0%Z (length a).

(* Why3 assumption *)
Definition max_lex (a:array Numbers.BinNums.Z) : Prop :=
  forall (b:array Numbers.BinNums.Z),
  ((length a) = (length b)) /\ is_permut b -> le_lex_sub b a 0%Z (length a).

(* Why3 assumption *)
Definition inc (a1:array Numbers.BinNums.Z) (a2:array Numbers.BinNums.Z) :
    Prop :=
  ((length a1) = (length a2)) /\
  lt_lex_sub a1 a2 0%Z (length a1) /\
  (forall (a3:array Numbers.BinNums.Z),
   ((length a1) = (length a3)) /\
   is_permut a3 /\ lt_lex_sub a1 a3 0%Z (length a1) ->
   le_lex_sub a2 a3 0%Z (length a1)).

Axiom occ_append_instance :
  forall {a:Type} {a_WT:WhyType a},
  forall (v:a) (m:Numbers.BinNums.Z -> a) (mid:Numbers.BinNums.Z)
    (u:Numbers.BinNums.Z),
  (0%Z <= mid)%Z /\ (mid <= u)%Z ->
  ((map.Occ.occ v m 0%Z u) =
   ((map.Occ.occ v m 0%Z mid) + (map.Occ.occ v m mid u))%Z).

Axiom permut_split :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:Numbers.BinNums.Z -> a) (b:Numbers.BinNums.Z -> a)
    (l:Numbers.BinNums.Z) (i:Numbers.BinNums.Z) (u:Numbers.BinNums.Z),
  (l <= i)%Z /\ (i < u)%Z -> map.MapPermut.permut a1 b l u ->
  map.MapPermut.permut a1 b l i -> map.MapPermut.permut a1 b i u.

(* Why3 assumption *)
Inductive cursor :=
  | mk_cursor : array Numbers.BinNums.Z -> Init.Datatypes.bool -> cursor.
Axiom cursor_WhyType : WhyType cursor.
Existing Instance cursor_WhyType.

(* Why3 assumption *)
Definition new (v:cursor) : Init.Datatypes.bool :=
  match v with
  | mk_cursor x x1 => x1
  end.

(* Why3 assumption *)
Definition current (v:cursor) : array Numbers.BinNums.Z :=
  match v with
  | mk_cursor x x1 => x
  end.

(* Why3 assumption *)
Definition sound (c:cursor) : Prop := is_permut (current c).

Axiom split_inc_sub :
  forall (a:array Numbers.BinNums.Z) (l:Numbers.BinNums.Z)
    (m:Numbers.BinNums.Z) (u:Numbers.BinNums.Z),
  ((0%Z <= l)%Z /\ (l <= m)%Z /\ (m < u)%Z /\ (u <= (length a))%Z) /\
  is_inc_sub a l (m + 1%Z)%Z /\ is_inc_sub a m u -> is_inc_sub a l u.

Axiom is_permut_split :
  forall (a:array Numbers.BinNums.Z) (b:array Numbers.BinNums.Z)
    (l:Numbers.BinNums.Z),
  ((0%Z <= l)%Z /\ (l < (length a))%Z /\ ((length a) = (length b))) /\
  is_permut a /\ is_permut b /\ permut a b 0%Z (length a) /\ permut a b 0%Z l ->
  permut a b l (length a).

Axiom is_permut_split_imply_permut_sub :
  forall (a:array Numbers.BinNums.Z) (b:array Numbers.BinNums.Z)
    (l:Numbers.BinNums.Z),
  ((0%Z <= l)%Z /\ (l < (length a))%Z /\ ((length a) = (length b))) /\
  is_permut a /\
  is_permut b /\ permut a b 0%Z (length a) /\ array_eq_sub a b 0%Z l ->
  permut_sub a b l (length a).

Axiom array_eq_imply_permut :
  forall (a:array Numbers.BinNums.Z) (b:array Numbers.BinNums.Z)
    (l:Numbers.BinNums.Z) (u:Numbers.BinNums.Z),
  ((0%Z <= l)%Z /\
   (l < u)%Z /\ (u <= (length a))%Z /\ ((length a) = (length b))) /\
  array_eq_sub a b l u -> permut a b l u.

Axiom permut_sym :
  forall (a:array Numbers.BinNums.Z) (b:array Numbers.BinNums.Z)
    (l:Numbers.BinNums.Z) (u:Numbers.BinNums.Z),
  permut a b l u <-> permut b a l u.

Axiom permut_sub_sym :
  forall (a:array Numbers.BinNums.Z) (b:array Numbers.BinNums.Z)
    (l:Numbers.BinNums.Z) (u:Numbers.BinNums.Z),
  permut_sub a b l u <-> permut_sub b a l u.

Axiom array_eq_sub_sym :
  forall (a:array Numbers.BinNums.Z) (b:array Numbers.BinNums.Z)
    (l:Numbers.BinNums.Z) (u:Numbers.BinNums.Z),
  array_eq_sub a b l u <-> array_eq_sub b a l u.

Axiom permut_trans :
  forall (a1:array Numbers.BinNums.Z) (a2:array Numbers.BinNums.Z)
    (a3:array Numbers.BinNums.Z),
  forall (l:Numbers.BinNums.Z) (u:Numbers.BinNums.Z), permut a1 a2 l u ->
  permut a2 a3 l u -> permut a1 a3 l u.

Axiom permut_sub_trans :
  forall (a1:array Numbers.BinNums.Z) (a2:array Numbers.BinNums.Z)
    (a3:array Numbers.BinNums.Z),
  forall (l:Numbers.BinNums.Z) (u:Numbers.BinNums.Z), permut_sub a1 a2 l u ->
  permut_sub a2 a3 l u -> permut_sub a1 a3 l u.

Axiom array_eq_sub_trans :
  forall (a1:array Numbers.BinNums.Z) (a2:array Numbers.BinNums.Z)
    (a3:array Numbers.BinNums.Z),
  forall (l:Numbers.BinNums.Z) (u:Numbers.BinNums.Z),
  array_eq_sub a1 a2 l u -> array_eq_sub a2 a3 l u -> array_eq_sub a1 a3 l u.

Axiom value_on_large_suffix :
  forall (a:array Numbers.BinNums.Z) (b:array Numbers.BinNums.Z)
    (l:Numbers.BinNums.Z) (u:Numbers.BinNums.Z),
  ((0%Z <= l)%Z /\
   (l < u)%Z /\ (u <= (length a))%Z /\ ((length a) = (length b))) /\
  permut_sub a b l u ->
  exists i:Numbers.BinNums.Z,
  ((l <= i)%Z /\ (i < u)%Z) /\ ((mixfix_lbrb b l) = (mixfix_lbrb a i)).

Axiom value_on_strict_suffix :
  forall (a:array Numbers.BinNums.Z) (b:array Numbers.BinNums.Z)
    (l:Numbers.BinNums.Z) (u:Numbers.BinNums.Z),
  ((0%Z <= l)%Z /\
   (l < u)%Z /\ (u <= (length a))%Z /\ ((length a) = (length b))) /\
  permut_sub a b l u /\ lt_lex_sub_at a b l u l ->
  exists i:Numbers.BinNums.Z,
  ((l < i)%Z /\ (i < u)%Z) /\ ((mixfix_lbrb b l) = (mixfix_lbrb a i)).

(* Why3 goal *)
Theorem inc_permut :
  forall (a:array Numbers.BinNums.Z) (b:array Numbers.BinNums.Z)
    (r:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  ((0%Z <= r)%Z /\
   (r < j)%Z /\ (j < (length a))%Z /\ ((length a) = (length b))) /\
  is_permut a /\
  is_dec_sub a (r + 1%Z)%Z (length a) /\
  is_permut b /\
  is_inc_sub b (r + 1%Z)%Z (length a) /\
  lt_lex_at a b r /\
  permut_sub a b r (length a) /\
  im_sup1 a r j /\ im_sup2 a r j /\ ((mixfix_lbrb b r) = (mixfix_lbrb a j)) ->
  inc a b.
(* Why3 intros a b r j
        ((h1,(h2,(h3,h4))),(h5,(h6,(h7,(h8,(h9,(h10,(h11,(h12,h13))))))))). *)
Proof.
(*Why3 intros a b r j
((h1,(h2,(h3,h4))),(h5,(h6,(h7,(h8,(h9,(h10,(h11,(h12,h13))))))))).*)
intros a b r j ((R0,(R1,(h3,len))),(h4,(h5,(h6,(h7,(h8,(h9,(h12,(h13,h14))))))))).
unfold inc. repeat split.
- apply len.
- firstorder.
- {
 intros c (h15,(h16,h17)).
 destruct h17 as [k [K [h17 h18]]].
 (* Goal: le_lex_sub b c 0 (length a) *)
 (* Subproof 1: permut a c 0 (length a) *)
 assert (permut a c 0 (length a)) as ps0. apply endoinj_permut.
 split. omega. split. apply h4. apply h16.
 (* Subproof 2: permut_sub a c k (length a) *)
 assert (permut_sub a c k (length a)) as ps1.
 apply is_permut_split_imply_permut_sub.
 split. firstorder. split. apply h4. split. apply h16.
 split. apply ps0.
 apply h17.
 case (Z.compare_spec k r); intro A.
 - { (* A: r = k *)
  assert (array_eq_sub b c 0 k) as H2.
  apply array_eq_sub_trans with a.
  rewrite A.
  apply array_eq_sub_sym.
  apply h8.
  apply h17.
  (* Subproof: permut_sub a c k (length a) *)
  assert (permut_sub b c k (length a)) as H.
  unfold permut_sub.
  split. apply H2.
  split.
  - {
   apply permut_trans with a.
   rewrite A.
   apply permut_sym.
   apply h9.
   apply ps1.
  }
  - firstorder.
  - {
   case (Z.compare_spec (mixfix_lbrb b k) (mixfix_lbrb c k)); intro B.
   - { (* B: b[k] = c[k] *)
    assert (array_eq_sub b c 0 (k+1)) as L.
    - {
     repeat split; try omega.
     unfold map_eq_sub.
     intros i I.
     assert ((0 <= i < k + 1)%Z -> (0 <= i < k )%Z \/ (i=k)%Z) as E; try omega.
     apply E in I.
     destruct I as [I1|I2].
     - apply H2. apply I1.
     - rewrite I2. apply B.
    }
    - {
     apply prefix_le_lex_sub with (k+1)%Z.
     split. apply L.
     apply min_lex_sub.
     - {
      repeat split; try omega.
      apply h6.
      rewrite <- A in h7.
      apply h7.
     }
     - {
      split.
      - {
       rewrite len. apply is_permut_split.
       split. repeat split; try omega.
       split. apply h6.
       split. apply h16.
       split.
       apply permut_trans with a.
       apply permut_sym.
       rewrite <- len.
       apply endoinj_permut.
       firstorder.
       rewrite <- len.
       apply ps0.
       apply array_eq_imply_permut.
       split. repeat split; try omega.
       apply L.
      }
      - apply h16.
     }
    }
   }
   - { (* B: b[k] < c[k] *)
    left.
    unfold lt_lex_sub.
    exists k.
    unfold lt_lex_sub_at.
    split. apply K.
    split. unfold array_eq_sub.
    repeat split; try omega.
    apply H2.
    apply B.
   }
   - {(* B: b[k] > c[k], not possible *)
    assert (exists i:int, (k < i < (length a))%Z /\ mixfix_lbrb c k = mixfix_lbrb a i ) as H1.
    apply value_on_strict_suffix.
    split. omega.
    split. apply ps1.
    unfold lt_lex_sub_at.
    repeat split; try omega.
    intros i I. omega.
    destruct H1 as [i[I H1]].
    unfold im_sup2 in h13; unfold im_sup1 in h12.
    assert ((k < i < (length a))%Z -> (k < i < j)%Z \/ i=j \/ (j < i < (length a))%Z) as E.
    omega.
    assert ( mixfix_lbrb b k < mixfix_lbrb a i  \/ mixfix_lbrb b k = mixfix_lbrb a i \/ mixfix_lbrb a i < mixfix_lbrb a k)%Z.
    apply E in I.
    destruct I as [I|[I|I]].
    rewrite <- A in h12,h13.
    left. rewrite <- h14,<-A in h12. apply h12. omega.
    right; left. rewrite I,A. apply h14.
    right; right. rewrite A. apply h13. omega.
    omega.
   }
  }
 }
 - { (* A: k < r *)
  assert (mixfix_lbrb a k = mixfix_lbrb b k).
  apply h8. intuition.
  left.
  unfold lt_lex_sub,lt_lex_sub_at.
  exists k.
  split. apply K.
  split.
  apply array_eq_sub_trans with a.
  apply array_eq_sub_sym.
  firstorder.
  apply h17.
  omega.
 }
 - { (* A: k > r, impossible *)
  assert ((mixfix_lbrb a k < mixfix_lbrb c k )%Z) as H.
  firstorder.
  assert (forall i:int, (k < i < (length a))%Z -> (mixfix_lbrb a i < mixfix_lbrb a k )%Z) as H1.
  intros i I.
  apply h5.
  omega.
  assert (exists i:int, (k <= i < (length a))%Z /\ (mixfix_lbrb c k = mixfix_lbrb a i )%Z) as H2.
  apply value_on_large_suffix.
  split. repeat split; try omega. 
  apply ps1.
  destruct H2 as [l [L L0]].
  case (Z.compare_spec l k); intro B.
  - { (* l = k *)
   rewrite B in L0.
   omega.
  }
  - (* l < k *) omega.
  - { (* l > k *)
   assert ((mixfix_lbrb a k > mixfix_lbrb c k)%Z).
   pose proof (H1 l) as H0.
   rewrite L0.
   omega.
   omega.
  }
 }
}
Qed.

