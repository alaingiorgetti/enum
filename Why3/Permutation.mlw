(********************************************************************)
(* Copyright 2018 Alain Giorgetti and Rémi Lazarini                 *)
(* FEMTO-ST institute                                               *)
(********************************************************************)

(********************************************************************)
(*  This software is distributed under the terms of the GNU Lesser  *)
(*  General Public License version 2.1                              *)
(********************************************************************)

(* Version described in [GL18].

[GL18] A. Giorgetti and R. Lazarini. Preuve de programmes d’énumération avec Why3.
       In AFADL’18, pages 14–19, 2018.
       http://afadl2018.ls2n.fr/wp-content/uploads/sites/38/2018/06/AFADL_Procs_2018.pdf.
*)

(** Extension of array.mlw. Restriction of map.MapInjection to arrays. *)
theory ArrayInjection
  use import int.Int
  use import array.Array
  use import map.MapInjection as M

  predicate injective (a: array int) = M.injective a.elts a.length

  predicate surjective (a: array int) = M.surjective a.elts a.length

  predicate range (a: array int) = M.range a.elts a.length

  lemma injective_surjective:
    forall a: array int.
    injective a -> range a -> surjective a

  use import map.Occ

  lemma injection_occ:
    forall a: array int.
    injective a <-> forall v:int. (occ v a.elts 0 a.length <= 1)

  lemma endoinjection_occ:
    forall a: array int. M.range (a.elts) a.length /\ injective a -> forall v:int.
      0 <= v < a.length -> (occ v a.elts 0 a.length = 1)

end

module Lex
  use import int.Int
  use import array.Array
  use import array.ArrayEq

  (** * Equality of sub-arrays is defined in array.ArrayEq *)

  (** * Equality of initial sub-sequences a1[0..u-1] and a2[0..u-1] *)

  predicate eq_prefix (a1 a2: array int) (u: int) = array_eq_sub a1 a2 0 u

  (** * Lexicographic order on arrays of integers *)

  (** ** Strict order *)

  predicate lt_lex_sub_at (a1 a2:array int) (l u:int) (i:int) = l <= i < u /\
    array_eq_sub a1 a2 l i /\ a1[i] < a2[i]

  predicate lt_lex_suffix_at (a1 a2: array int) (l: int) (i:int) = lt_lex_sub_at a1 a2 l a1.length i

  predicate lt_lex_at (a1 a2: array int) (i:int) = a1.length = a2.length /\ lt_lex_suffix_at a1 a2 0 i

  predicate lt_lex_sub (a1 a2: array int) (l u: int) =
        exists i:int. lt_lex_sub_at a1 a2 l u i

  (* warning: length a1 = length a2 not checked *)
  predicate lt_lex_suffix (a1 a2: array int) (l: int) = lt_lex_sub a1 a2 l a1.length

  predicate lt_lex (a1 a2: array int) = a1.length = a2.length /\ lt_lex_suffix a1 a2 0

  predicate le_lex_sub (a1 a2: array int) (l u: int) = lt_lex_sub a1 a2 l u \/
    array_eq_sub a1 a2 l u

  predicate le_lex_suffix (a1 a2: array int) (l: int) = le_lex_sub a1 a2 l a1.length

  predicate le_lex (a1 a2: array int) = a1.length = a2.length /\ le_lex_suffix a1 a2 0

  let rec lemma not_array_eq_sub (a b: array int) (l u: int) : unit
    requires { 0 <= l < u <= a.length = b.length }
    requires { not (array_eq_sub a b l u) }
    variant  { u - l }
    ensures  { exists i:int. l <= i < u /\ array_eq_sub a b l i /\ a[i] <> b[i] }
  =
    if a[l] = b[l] then not_array_eq_sub a b (l+1) u

  (* Proved with Z3 4.5.1 *)
  lemma total_order:
    forall a b: array int, l u: int. 0 <= l < u <= a.length = b.length /\ not (lt_lex_sub b a l u) ->
      le_lex_sub a b l u
end


module LexPermutation
  use import Lex
  use import ArrayInjection
  use import int.Int
  use import array.Array
  use import array.ArrayEq (* for equality array_eq_sub of sub-arrays *)
  use import array.ArrayPermut

  predicate is_permut (a:array int) =  range a /\ injective a

  predicate is_id_sub (a:array int) (l u:int) = forall i:int. l <= i < u -> a[i] = i
  predicate is_id (a:array int) = is_id_sub a 0 a.length

  predicate is_inc_sub (a: array int) (l u:int) = forall i j:int. l <= i < j < u -> a[i] < a[j]
  predicate is_inc (a: array int) = is_inc_sub a 0 a.length
  predicate is_dec_sub (a: array int) (l u:int) = forall i j:int. l <= i < j < u -> a[j] < a[i]
  predicate is_dec (a: array int) = is_dec_sub a 0 a.length

  lemma max_lex_sub:
  forall a: array int, l u: int. 0 <= l < u <= a.length /\ injective a /\ is_dec_sub a l u ->
  forall b:array int. permut a b l u /\ injective b -> le_lex_sub b a l u

  lemma min_lex_sub:
  forall a: array int, l u: int. 0 <= l < u <= a.length /\ injective a /\ is_inc_sub a l u ->
  forall b:array int. permut a b l u /\ injective b -> le_lex_sub a b l u

  (* a is the smallest permutation in lexicographic order *)
  predicate min_lex (a: array int) = forall b: array int.
    a.length = b.length /\ is_permut b -> le_lex_sub a b 0 a.length

  (* a is the biggest permutation in lexicographic order *)
  predicate max_lex (a: array int) = forall b: array int.
    a.length = b.length /\ is_permut b-> le_lex_sub b a 0 a.length

  (* (inc a1 a2) holds iff a2 is the smallest array larger than a1 *)
  predicate inc (a1 a2: array int) = a1.length = a2.length /\
    lt_lex_sub a1 a2 0 a1.length /\ forall a3: array int. a1.length = a3.length /\
      is_permut a3 /\ lt_lex_sub a1 a3 0 a1.length -> le_lex_sub a2 a3 0 a1.length

end

module Permutation
  use import int.Int
  use import ref.Ref
  use import ArrayInjection
  use import Lex
  use import LexPermutation
  use import array.Array
  use import array.ArraySwap
  use import array.ArrayExchange
  use import array.ArrayEq
  use import array.ArrayPermut

  type cursor = {
        current: array int; (* current permutation *)
    mutable new: bool;      (* true iff current is a new permutation *)
  }

  predicate sound (c: cursor) = is_permut c.current

  let create_cursor (n: int) : cursor
    requires { n >= 0 }
    ensures  { result.new && sound result }
    ensures  { min_lex result.current }
  = let p = make n 0 in
    for i = 0 to n-1 do
      invariant { 0 <= i <= n }
      invariant { is_id_sub p 0 i }
      p[i] <- i
    done;
    assert { is_inc p };
    { current = p; new = true }

  (* reverse array a between a[l] and a[u-1] *)
  let reverse (a: array int) (l u: int) : unit
    requires { 0 <= l < u <= a.length }
    requires { is_permut a }
    ensures  { is_permut a }
    ensures  { eq_prefix a (old a) l }
  = 'L:
    let x = ref l in
    let y = ref (u-1) in
    while !x < u && l <= !y && !x < !y do
      invariant { l <= !x < u }
      invariant { l <= !y < u }
      invariant { is_permut a }
      invariant { eq_prefix a (at a 'L) l }
      variant   { !y - !x }
      swap a !x !y;
      y := !y - 1;
      x := !x + 1
    done

  let next (c: cursor) : unit
    requires { sound c }
    ensures  { sound c }
    ensures  { c.new -> lt_lex (old c.current) c.current }
    ensures  { not c.new -> array_eq (old c.current) c.current }
    ensures  { not c.new -> max_lex c.current }
    (*ensures  { c.new -> inc (old c.current) c.current }*)
  =
    'L:
    let p = c.current in
    let n = p.length in
    if n <= 1 then
      c.new <- false
    else
      let r = ref (n-2) in (* 1. find the rightmost index !r s.t. p[!r] < p[!r+1] *)
      while !r >= 0 && p[!r] > p[!r+1] do
        invariant { -1 <= !r <= n-2 }
        invariant { p[!r] > p[!r+1] -> is_dec_sub p !r n }
        invariant { p[!r] < p[!r+1] \/ !r= (-1) -> is_dec_sub p (!r+1) n }
        variant   { !r + 1 }
        r := !r - 1
      done;
      if !r < 0 then (* last array reached. *)
        c.new <- false
      else (* 2. Find rightmost (i.e. smallest) element p[!j] greater than p[!r]: *)
        let j = ref (n-1) in
        while !j > !r + 1 && p[!r] >= p[!j] do
          invariant { !r + 1 <= !j <= n-1 }
          variant   { !j }
          j := !j - 1
        done;
        swap p !r !j; (* 3. swap *)
        reverse p (!r+1) n; (* 4. reverse suffix *)
        c.new <- true

end
