(********************************************************************)
(* Copyright 2018 Alain Giorgetti and RÃ©mi Lazarini                 *)
(* FEMTO-ST institute                                               *)
(********************************************************************)

(********************************************************************)
(*  This software is distributed under the terms of the GNU Lesser  *)
(*  General Public License version 2.1                              *)
(********************************************************************)

(* Permutation1.mlw is Permutation.mlw completed to prove completeness. *)

(** Extension of array.mlw. Restriction of map.MapInjection to arrays. *)
theory ArrayInjection
  use import int.Int
  use import array.Array
  use import map.MapInjection as M

  predicate injective (a: array int) = M.injective a.elts a.length

  predicate surjective (a: array int) = M.surjective a.elts a.length

  predicate range (a: array int) = M.range a.elts a.length

  lemma injective_surjective:
    forall a: array int.
    injective a -> range a -> surjective a

  use import map.Occ

  lemma injection_occ:
    forall a: array int.
    injective a <-> forall v:int. (occ v a.elts 0 a.length <= 1)

  lemma endoinjection_occ:
    forall a: array int. M.range (a.elts) a.length /\ injective a -> forall v:int.
      0 <= v < a.length -> (occ v a.elts 0 a.length = 1)

end

module Lex
  use import int.Int
  use import array.Array
  use import array.ArrayEq

  (** * Equality of sub-arrays is defined in array.ArrayEq *)

  (** * Equality of initial sub-sequences a1[0..u-1] and a2[0..u-1] *)

  predicate eq_prefix (a1 a2: array int) (u: int) = array_eq_sub a1 a2 0 u

  (** * Lexicographic order on arrays of integers *)

  (** ** Strict order *)

  predicate lt_lex_sub_at (a1 a2:array int) (l u:int) (i:int) = l <= i < u /\
    array_eq_sub a1 a2 l i /\ a1[i] < a2[i]

  predicate lt_lex_at (a1 a2: array int) (i:int) = a1.length = a2.length /\ lt_lex_sub_at a1 a2 0 a1.length i

  predicate lt_lex_sub (a1 a2: array int) (l u: int) =
        exists i:int. lt_lex_sub_at a1 a2 l u i

  predicate lt_lex (a1 a2: array int) = a1.length = a2.length /\ lt_lex_sub a1 a2 0 a1.length

  predicate le_lex_sub (a1 a2: array int) (l u: int) = lt_lex_sub a1 a2 l u \/
    array_eq_sub a1 a2 l u

  lemma prefix_le_lex_sub:
    forall a b:array int, l u:int. eq_prefix a b l /\ le_lex_sub a b l u -> le_lex_sub a b 0 u

  let rec lemma not_array_eq_sub (a b: array int) (l u: int) : unit
    requires { 0 <= l < u <= a.length = b.length }
    requires { not (array_eq_sub a b l u) }
    variant  { u - l }
    ensures  { exists i:int. l <= i < u /\ array_eq_sub a b l i /\ a[i] <> b[i] }
  =
    if a[l] = b[l] then not_array_eq_sub a b (l+1) u

  (* Proved with Z3 4.7.1 *)
  lemma total_order:
    forall a b: array int, l u: int. 0 <= l < u <= a.length = b.length /\ not (lt_lex_sub b a l u) ->
      le_lex_sub a b l u
end


module LexPermutation
  use import Lex
  use import ArrayInjection
  use import int.Int
  use import array.Array
  use import array.ArrayEq (* for equality array_eq_sub of sub-arrays *)
  use import array.ArrayPermut

  predicate is_permut (a:array int) =  range a /\ injective a

  lemma endoinj_permut:
    forall a b: array int. 0 <= a.length = b.length /\
      is_permut a /\ is_permut b -> permut a b 0 a.length

  predicate is_id_sub (a:array int) (l u:int) = forall i:int. l <= i < u -> a[i] = i

  (* These two predicates specify that a[k] is the smallest value bigger than a[r] in array a[r+1..a.length] *)
  predicate im_sup1 (a: array int) (r k:int) = forall i:int. r < i < k -> a[k] < a[i]
  predicate im_sup2 (a: array int) (r k:int) = forall i:int. k < i < a.length -> a[i] < a[r]

  (* Predicates to specify increasing and decreasing arrays *)
  predicate is_inc_sub (a: array int) (l u:int) = forall i j:int. l <= i < j < u -> a[i] < a[j]
  predicate is_inc (a: array int) = is_inc_sub a 0 a.length
  predicate is_dec_sub (a: array int) (l u:int) = forall i j:int. l <= i < j < u -> a[j] < a[i]

  lemma min_lex_sub:
  forall a: array int, l u: int. 0 <= l < u <= a.length /\ injective a /\ is_inc_sub a l u ->
  forall b:array int. permut a b l u /\ injective b -> le_lex_sub a b l u

  lemma max_lex_sub:
  forall a: array int, l u: int. 0 <= l < u <= a.length /\ injective a /\ is_dec_sub a l u ->
  forall b:array int. permut a b l u /\ injective b -> le_lex_sub b a l u

  (* a is the smallest permutation in lexicographic order *)
  predicate min_lex (a: array int)  =
  forall b: array int. a.length = b.length /\ is_permut b ->  le_lex_sub a b 0 a.length

  (* a is the largest permutation in lexicographic order *)
  predicate max_lex (a: array int)  =
  forall b: array int. a.length = b.length /\ is_permut b ->  le_lex_sub b a 0 a.length

  (* (inc a1 a2) holds iff a2 is the smallest array larger than a1 *)
  predicate inc (a1 a2: array int) = a1.length = a2.length /\
    lt_lex_sub a1 a2 0 a1.length /\ forall a3: array int. a1.length = a3.length /\
      is_permut a3 /\ lt_lex_sub a1 a3 0 a1.length -> le_lex_sub a2 a3 0 a1.length
end

module Permutation
  use import int.Int
  use import ref.Ref
  use import ArrayInjection
  use import Lex
  use import LexPermutation
  use import array.Array
  use import array.ArraySwap
  use import array.ArrayExchange
  use import array.ArrayEq
  use import array.ArrayPermut

  type cursor = {
        current: array int; (* current permutation *)
    mutable new: bool;      (* true iff current is a new permutation *)
  }

  predicate sound (c: cursor) = is_permut c.current

  let create_cursor (n: int) : cursor
    requires { n >= 0 }
    ensures  { result.new && sound result }
    ensures  { min_lex result.current }
  = let p = make n 0 in
    for i = 0 to n-1 do
      invariant { 0 <= i <= n }
      invariant { is_id_sub p 0 i }
      p[i] <- i
    done;
    assert { is_inc p };
    { current = p; new = true }

  (* split predicate is_inc_sub to prove last postcondition of reverse *)
  lemma split_inc_sub:
   forall a: array int, l m u:int. 0 <= l <= m < u <= a.length /\
     is_inc_sub a l (m+1) /\ is_inc_sub a m u -> is_inc_sub a l u

  (* reverse array a between a[l] and a[u-1] *)
  let reverse (a: array int) (l u: int) : unit
    requires { 0 <= l < u <= a.length }
    requires { is_permut a }
    requires { is_dec_sub a l u }
    ensures  { is_permut a }
    ensures  { permut_sub (old a) a l u }
    ensures  { is_inc_sub a l u }
  =
    'L:
    let x = ref l in
    let y = ref (u-1) in
    while !x < u && l <= !y && !x < !y do
      invariant { l <= !x < u }
      invariant { l <= !y < u }
      invariant { is_permut a }
      invariant { permut_sub (at a 'L) a l u }
      invariant { is_inc_sub a l (!x+1) }
      invariant { is_inc_sub a !y u }
      invariant { array_eq_sub (at a 'L) a !x (!y+1) }
      variant   { !y - !x }
      swap a !x !y;
      assert { is_permut a }; (* speed up proof *)
      y := !y - 1;
      x := !x + 1
    done

  (* The following lemmas are proved with SMT solvers and used as axioms in Coq: *)

  (* split permut *)
  lemma permut_split:
    forall a b: array int, l: int. 0 <= l < a.length = b.length /\ is_permut a /\ is_permut b /\
      permut a b 0 a.length /\ permut a b 0 l -> permut a b l a.length

  lemma permut_split_imply_permut_sub:
    forall a b: array int, l: int. 0 <= l < a.length = b.length /\ is_permut a /\ is_permut b /\
      permut a b 0 a.length /\ array_eq_sub a b 0 l -> permut_sub a b l a.length

  (* array_eq_sub implies permut in the same interval *)
  lemma array_eq_imply_permut:
    forall a b:array int, l u:int. 0 <= l < u <= a.length = b.length /\
      array_eq_sub a b l u -> permut a b l u

  (* permut and permut_sub are symmetric *)
  lemma permut_sym:
    forall a b:array int, l u: int. permut a b l u <-> permut b a l u

  lemma permut_sub_sym:
    forall a b:array int, l u: int. permut_sub a b l u <-> permut_sub b a l u

  lemma array_eq_sub_sym:
    forall a b: array int, l u: int. array_eq_sub a b l u <->  array_eq_sub b a l u

  (* permut is transitive *)
  lemma permut_trans:
    forall a1 a2 a3 : array int. forall l u : int.
      permut a1 a2 l u -> permut a2 a3 l u -> permut a1 a3 l u

  lemma permut_sub_trans:
    forall a1 a2 a3 : array int. forall l u : int.
      permut_sub a1 a2 l u -> permut_sub a2 a3 l u -> permut_sub a1 a3 l u

  (* array_eq_sub is transitive *)
  lemma array_eq_sub_trans:
    forall a1 a2 a3 : array int. forall l u : int.
      array_eq_sub a1 a2 l u -> array_eq_sub a2 a3 l u -> array_eq_sub a1 a3 l u

  (* condition to find value b[l] on large or strict suffix if we have permut_sub a b l u*)
  lemma value_on_large_suffix:
    forall a b: array int, l u: int. 0 <= l < u <= a.length = b.length /\ permut_sub a b l u ->
      exists i:int. l <= i < u /\ b[l] = a[i]

  lemma value_on_strict_suffix:
    forall a b: array int, l u: int. 0 <= l < u <= a.length = b.length /\
      permut_sub a b l u /\ lt_lex_sub_at a b l u l -> exists i:int. l < i < u /\ b[l] = a[i]

  lemma inc_permut:
    forall a b: array int, r j:int. 0 <= r < j < a.length = b.length /\
    is_permut a /\ is_dec_sub a (r+1) a.length /\
    is_permut b /\ is_inc_sub b (r+1) a.length /\
    lt_lex_at a b r /\ permut_sub a b r a.length /\
    im_sup1 a r j /\ im_sup2 a r j /\ b[r] = a[j]
    -> inc a b

  let next (c: cursor) : unit
    requires { sound c }
    ensures  { sound c }
    ensures  { not c.new -> array_eq (old c.current) c.current }
    ensures  { not c.new -> max_lex c.current }
    ensures  { c.new -> lt_lex (old c.current) c.current}
    ensures  { c.new -> inc (old c.current) c.current} (* imply progress *)
  =
    'L:
    let p = c.current in
    let n = p.length in
    if n <= 1 then
      c.new <- false
    else
      let r = ref (n-2) in (* 1. find the rightmost index !r s.t. p[!r] < p[!r+1]: *)
      while !r >= 0 && p[!r] > p[!r+1] do
        invariant { -1 <= !r <= n-2 }
        invariant { is_dec_sub p (!r+1) n }
        variant   { !r + 1 }
        r := !r - 1
      done;
      if !r < 0 then (* last array reached. *)
        c.new <- false
      else (* 2. Find rightmost (i.e. smallest) element p[!j] greater than p[!r]: *)
        let j = ref (n-1) in
        while p[!r] > p[!j] do
          invariant { !r + 1 <= !j <= n-1 }
          invariant { im_sup2 p !r !j }
          variant   { !j }
          j := !j - 1
        done;
        swap p !r !j; (* 3. swap *)
        reverse p (!r+1) n; (* 4. reverse suffix *)
        assert { lt_lex_at (at p 'L) p !r };
        c.new <- true
end
